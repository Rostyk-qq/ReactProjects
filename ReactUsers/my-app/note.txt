React
jsx дозволяє використовувати html в коді

ReactDom.createRoot(elementToRender)
.render(
    <Component />
)

useState виконується синхронно з useEffect
звязування називається то коли ми звязуємо то шо буде робитисся в середині чогось 
і буде попадати в стан тобто в useState

якшо ми створюємо Class в React
то ситаксис State змінюється:

   constructor(props) {
        super(props);
        this.state = {
            /*
            тобто тут ми створюємо
            шось на подобі useState
             */
            count: 0
        }


const [value, setValue] = useState(0)
this.state.count === value
this.seState({count: this.state.count + 1}) ===  setValue

i щоб функції розуміло що ми використовуємо this state
ми мусимо його туда bind:
this.функція = this.функція.bind(this)
..
React hooks не можна використовувати в функція обєктах...
..
для чого в React використовувати ключі
для продуктивності rendering продуктивності роботи
якшо ми будемо робити якісь видалення або ноавіть заміни
то щоб ключі між собою не плуталися
..
якшо ми хочемо створити style для якогось
component нам потрібно в назві використовувати module
воно згенерує правильне class імя
..
props.children - вказує на вміст тега
..
тобто props це як обєкт який містить те що передаємо
{} - така передача називається передача напряму
..
event.target - це як пошукова система того елемента або тега якого вкажемо
..
useState - використовується для куруйочого елементу
useRef - ні, він використовується для незмінного елементу
..
onChange - відслідковує зміну елемента
value це його значення
..
ref не контрольований елемент(hook)
якшо ми використовуємо власноруч створений компонент input або button
то потрібно створену фнкцію огортати в forwardRef() i в поле для аттрибутів додовати ref={ref}
..
useMemo(callback, deps) - суто продуктивність роботи
діє виконуєтьмся після зміни вказаних елементів deps -
масив вказаних елементів
callBack - те що виконається при зміні
і вона не повторює дії вона бере готовий після 1-го разу сортування
такий процес називається мемоізація
..
в особистому хуці ми мусимо
використовувати react hooks
useMemo useState і тд...
...
життаєвий цикл компонентів useEffect
mount - монтування
update - оновлення
unmount - розмонтування
..
після кожного axios ми получаємо data
а також ми можемо получати з header x-total-count
тобто це всі пости на сторінці
..
в кожному react коді нам потрібно використовуввати decomposition
тобто робити локанічний код
..
react-router-dom
<BrowserRouter> - головна оболонка
<Routes> - це як Switch
а коли не спрацювали Routes
спрацює останній в ньому з Navigate link='/' to={Element}
..
також коли ми використуваємо a - link
то SPA - не працює бо стається оновлення сторінки
треба використовувати:
<Link to=''></Link>
...
це конструкція
<Routes>
   <Route path='/posts' element={<Posts/>} />
   <Route path='/about' element={<About/>} />
   <Route path="*" element={<Navigate to="/about" replace />} />
</Routes>
дорівнює тій в якої використовується Switch Redirect

...

також ми можемо динамічно викоритовувати
Link - тобто в button і тд
const navigate = useNavigate()
наприклад в posts
navigate('/posts')

наступний випадок це коди ми в
рендері сторінок говорими що в нас динамічний url

приклад:
/posts/:id - тобто цей id буде змінюватися

і ще один коли в нас в рендері є таке

<Route path='/posts' element={<Posts/>} />
<Route path='/posts/:id' element={<About/>} />

коли в нас path частково повторюється
ми для розрізняння мусимо викоритовувати
exact перед ним

...
useParams - воно розпізнає через рендер поточний path і по ньому бере параметри з url даного component
...
useContext
вбільшості його робота така як redux
тобто він змінює значення залежно від дії
також він доступний на глобальному рівні

Сунтаксис:
спочатку нам потрібно створити createContext(null) тобто з контекст з аочатковим значення null
нам цем як в redux потрібно огорнути весь глобальний код:

const Context = createContext(null)

<Context.Provider value={{state... etc}}>
    весь код
</Context.Provider>
шоб побачити їх:
const {states} = useContext(Context)
...
також IntersectionObserver(callback)
він використовується для безкінечної ленти тобто для ренденгу

ситаксис ми його використовуємо useEffect
useEffect(() => {
    const callback = (entries, observer) => {
        тут ми робимо різні махінації якшо екран бачить елемент або елементи
        елементи ми можемо басити тут entries
        також шоб чітко відображався елемент коли ми зверху вниз наводимся екраном
        entries[0].isIntersecting - тобто бул значення про вивдимість
    }
    тут ми отримуємо доступ до currentElement
    наприклад ми створили div елемент
        bser.current = new IntersectionObserver(callback);
        obser.current.observe(lastPost.current) в obser.current поміщаємо div тобто слідкуємо за ним
}, [])

...
також шоб уникнути оновлення ми пішли хитрим способ
ми створили додатковий State який початкове значення мав true
потім в useEffect після того чи авторизувалися ми чи нє
ми ставимо false
і додаємо провірку перед рендерингом основним
якшо цей State === true ми шось повертаємо на глобальному рівні замість рендеру

і коли ми робимо оновлення
цей state true false - весь час і не доходить до рендера і тому не буде оновлення і перекидання нв іншу сторінку
...
window.location.reload() оновити сторінку
...